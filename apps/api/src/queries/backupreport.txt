const { Op, Sequelize } = require('sequelize');
// const { Order, OrderDetail, User, Store, ProductStock } = require('./models');
import Order from "../models/order.model";
import OrderDetail from "../models/orderDetail.model";
import User from "../models/user.model";
import Store from "../models/store.model";
import ProductStock from "../models/productStock.model";
import Product from "../models/product.model";
import ProductCategory from "../models/productCategory.model";
import ProductCategory_has_Product from "../models/productCategory_has_Product.model";



const getSalesByDateQuery = async (startDate, endDate, storeId, categoryId, productId) => {
    try {
      const salesData = await OrderDetail.findAll({
        attributes: [
          [Sequelize.fn('DATE_FORMAT', Sequelize.col('Order.orderDate'), '%Y-%m-%d'), 'date'],
          [Sequelize.fn('sum', Sequelize.col('subtotal')), 'totalSales'],
          [Sequelize.fn('sum', Sequelize.col('quantity')), 'totalQuantity'],
          [Sequelize.fn('count', Sequelize.col('Order.id')), 'totalTransactions'],
          [Sequelize.col('Order->Store.id'), 'storeId'], // Adding Store ID to the select
          [Sequelize.col('Order->Store.name'), 'storeName'], // Adding Store Name to the select
          [Sequelize.col('ProductStock->Product.id'), 'productId'], // Adding Store Name to the select
          [Sequelize.col('ProductStock->Product.name'), 'productName'], // Adding Store Name to the select
          [Sequelize.col('ProductStock->Product->ProductCategory_Has_Product.ProductCategory.id'), 'categoryId'], // Adding Store Name to the select

          // Add other Store columns as needed
        ],
        include: [
          {
            model: Order,
            attributes: [],
            include: [
              {
                model: Store,
                attributes: [], // Exclude Store columns from the main query
              },
            ],
            where: {
              [Op.and]: [
                { orderDate: { [Op.gte]: new Date(`${startDate}T00:00:00.000Z`) } },
                { orderDate: { [Op.lte]: new Date(`${endDate}T23:59:59.999Z`) } },
                // { store_idstore: storeId ? storeId : { [Op.ne]: null } },
                storeId ? { store_idstore: storeId } : {},
              ],
            },
          },
          {
            
                model: ProductStock,
                include: [
                  {
                    model: Product,
                    include: [
                      {
                        model: ProductCategory_has_Product,
                        attributes: [],
                        include: [
                          {
                            model: ProductCategory,
                            where: { id: categoryId ? categoryId : { [Op.ne]: null } },
                            attributes: [], // Exclude ProductCategory columns from the main query
                          },
                        ],
                      },
                    ],
                    where: { id: productId ? productId : { [Op.ne]: null } },
                    attributes: [], // Exclude Product columns from the main query
                  },
                ],
                attributes: [], // Exclude ProductStock columns from the main query
          },
        ],
        group: [
          Sequelize.fn('DATE_FORMAT', Sequelize.col('Order.orderDate'), '%Y-%m-%d'),
          Sequelize.col('Order->Store.id'), // Include Store ID in the group by
          Sequelize.col('Order->Store.name'), // Include Store Name in the group by
          Sequelize.col('ProductStock->Product.id'), // Adding Store Name to the select
          Sequelize.col('ProductStock->Product.name'), // Adding Store Name to the select
          Sequelize.col('ProductStock->Product->ProductCategory_Has_Product.ProductCategory.id'), // Adding Store Name to the select
          // [Sequelize.col('ProductStock->Product->ProductCategory.id'), 'categoryId'], // Adding Store Name to the select

          // Add other Store columns as needed
        ],
        raw: true,
        dialect: 'mysql', // Set the dialect explicitly
      });
  
      const aggregatedData = {
        totalSales: 0,
        totalQuantity: 0,
        totalTransactions: 0,
        saleDate: null,
        storeId: null,
        storeName: null,
        productId: null,
        productName: null,
      };
  
      salesData.forEach((item) => {
        aggregatedData.totalSales += parseFloat(item.totalSales);
        aggregatedData.totalQuantity += parseInt(item.totalQuantity);
        aggregatedData.totalTransactions += parseInt(item.totalTransactions);
        aggregatedData.saleDate = item.date;
        aggregatedData.storeId = storeId ? item.storeId : null;
        aggregatedData.storeName =  storeId ? item.storeName : null;
        aggregatedData.productId = productId ? item.productId : null;
        aggregatedData.productName = productId ? item.productName : null;
        aggregatedData.categoryId = categoryId ? item.categoryId : null;
      });
  
      return [aggregatedData];

      // masih error di categoryId
  
    } catch (err) {
      throw err;
    }
  };
  



const getProductsByTransactionQuery = async (transactionId) => {
  try {
    const res = await Order.findByPk(transactionId, {
      include: [
        {
          model: OrderDetail,
          include: [
            {
              model: ProductStock,
            },
          ],
        },
        {
          model: User,
        },
        {
          model: Store,
        },
      ],
    });
    return res;
  } catch (err) {
    throw err;
  }
};

// const createSalesReportQuery = async (startDate, endDate, page, pageSize, sortOrder, categoryId, productId, storeId) => {
//     try {
//       const offset = (page - 1) * (pageSize || 0);
  
//       const res = await OrderDetail.findAndCountAll({
//         required: true,
//         include: [
//           {
//             model: Order,
//             where: storeId ? { store_idstore: storeId } : {},
//             required: true,
//             include: [
//               {
//                 model: User,
//                 attributes: [],
//               },
//               {
//                 model: Store,
//                 attributes: [],
//                 where: storeId ? { id: storeId } : {},
//               },
//             ],
//             where: {
//               orderDate: {
//                 [Op.gte]: new Date(`${startDate}T00:00:00.000Z`),
//                 [Op.lte]: new Date(`${endDate}T23:59:59.999Z`),
//               },
//             },
//           },
//           {
//             model: ProductStock,
//             required: true,
//             include: [
//               {
//                 model: Product,
//                 attributes: ['id','name'],
//                 include: [
//                   {
//                     model: ProductCategory,
//                     attributes: [],
//                     where: categoryId ? { id: categoryId } : {},
//                   },
//                 ],
//                 where: productId ? { id: productId } : {},
//               },
//             ],
//             attributes: ['id'],
//           },
//         ],
//         order: [[{ model: Order }, 'orderDate', sortOrder]],
//         offset: offset,
//         limit: pageSize ? parseInt(pageSize) : undefined,
//       });
      
  
//       // const totalPages = Math.ceil(res.count / pageSize);
//     const totalPages = Math.ceil(res.count / (pageSize || res.count));

  
//       return {
//         total: res.count,
//         data: res.rows,
//         totalPages: totalPages,
//       };
//     } catch (err) {
//       throw err;
//     }
//   };

const createSalesReportQuery = async (startDate, endDate, page, pageSize, sortOrder, categoryId, productId, storeId) => {
  try {
    console.log('query', startDate, endDate, page, pageSize, sortOrder, categoryId, productId, storeId);

    const offset = (page - 1) * (pageSize || 0);

    const orderDetailQuery = {
      attributes: ['id', 'order_idorder', 'quantity', 'subtotal', 'productStock_idproductStock'],
      include: [
        {
          model: Order,
          attributes: ['id', 'user_iduser', 'store_idstore', 'status', 'totalAmount', 'orderDate','codeTransaction'],
          where: {
            orderDate: {
              [Op.gte]: new Date(`${startDate}T00:00:00.000Z`),
              [Op.lte]: new Date(`${endDate}T23:59:59.999Z`),
            },
          },
        },
      ],
      order: [[{ model: Order }, 'orderDate', sortOrder]],
      offset: offset,
      limit: pageSize ? parseInt(pageSize) : undefined,
    };

    const orderDetailResult = await OrderDetail.findAndCountAll(orderDetailQuery);
    const orderDetailRows = orderDetailResult.rows;
    const orderDetailCount = orderDetailResult.count;

    const orderIds = orderDetailRows.map((orderDetail) => orderDetail.Order.id);

    const productStockQuery = {
      where: {
        // Add any other conditions for ProductStock here
      },
      include: [
        {
          model: Product,
          attributes: ['name'],
          include: [
            {
              model: ProductCategory,
              attributes: [],
              where: categoryId ? { id: categoryId } : {},
            },
          ],
          where: productId ? { id: productId } : {},
        },
      ],
    };

    const productStocks = await ProductStock.findAndCountAll(productStockQuery);

    const productStockIds = productStocks.rows.map((stock) => stock.id);
    const productIds = productStocks.rows.map((stock) => stock.product_idproduct);

    const totalPages = Math.ceil(orderDetailCount / (pageSize || orderDetailCount));

    return {
      total: orderDetailCount,
      data: orderDetailRows,
      totalPages: totalPages,
    };
  } catch (err) {
    console.error('Error in createSalesReportQuery:', err);
    throw err;
  }
};






module.exports = {
  getSalesByDateQuery,
  getProductsByTransactionQuery,
  createSalesReportQuery,
};
